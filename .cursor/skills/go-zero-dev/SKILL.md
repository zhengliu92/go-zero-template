---
name: go-zero-dev
description: Comprehensive development guidelines for Go-Zero projects including API design, database operations, caching, logging, and code architecture. Use when working with Go-Zero projects, designing APIs, implementing repository patterns, managing caches, or handling database operations.
---

# Go-Zero Development Best Practices

## Quick Reference

### Makefile Commands

| Command | Purpose |
|---|---|
| `make gen` | Generate code from API files |
| `make format` | Format API files |
| `make run` | Start the service |
| `make mt` | Tidy Go module dependencies |

### Cursor Commands

Use `Ctrl+K` or `Cmd+K` to trigger:

| Command | Purpose |
|---|---|
| `check-cache` | Verify cache architecture compliance |
| `fix-cache` | Fix cache architecture violations |
| `guard` | Add permission checks to endpoints |
| `opt` | Check for code optimization opportunities |

---

## Architecture Rules

### Layered Architecture

```
Logic Layer (internal/logic/)
    ↓ calls
Repository Layer (internal/db/)
    ↓ operates
Database / Cache
```

**Core Rules:**
- Logic layer MUST use Repository, never direct DB access
- Repository layer handles ALL cache operations
- Logic layer NEVER touches cache directly

### Repository Pattern

```go
// ✅ Correct: Through Repository
user, err := l.svcCtx.Repository.User.GetByLoginName(l.ctx, req.LoginName)

// ❌ Wrong: Direct DB access in Logic
err = l.svcCtx.DB.Where("login_name = ?", req.LoginName).First(&user).Error
```

---

## API Design

### Auto-Generated Files

**NEVER** edit files with `// Code generated by goctl. DO NOT EDIT.`

**Workflow:**
1. Edit `api/*.api` files
2. Run `make gen`
3. Implement business logic in generated Logic files

### Required @doc Annotations

```go
@doc (
    summary: "Create cron task"
    description: "Creates a new task, requires admin permission"
)
@handler CreateCronTaskHandler
post /cron-tasks (CreateCronTaskRequest) returns (CreateCronTaskResponse)
```

- **summary**: 5-15 words, verb-first
- **description**: Detailed explanation with permissions

### Field Comments

```go
type CronTask {
    ID int64 `json:"id"` // Task ID
    Name string `json:"name"` // Task name
    Status string `json:"status"` // Status: enabled-enabled, disabled-disabled
    CreatedAt string `json:"created_at"` // Creation time (ISO8601)
}
```

**Rules:**
- Enum fields list all possible values
- Format-specific fields document the format
- ALL fields must have comments

---

## Database Operations

### Single Record Queries

Use helper functions from `internal/db/helper.go`:

| Function | Use Case |
|---|---|
| `FirstOrNil[T]` | Query by primary key/unique index |
| `TakeOrNil[T]` | Order doesn't matter |
| `LastOrNil[T]` | Get latest record |

These automatically convert `gorm.ErrRecordNotFound` to `nil, nil`.

```go
// Repository method example
func (r *UserRepository) GetByID(ctx context.Context, id int) (*model.User, error) {
    return FirstOrNil[model.User](r.db.WithContext(ctx).Where("id = ?", id))
}
```

### Database Field Update Workflow

When modifying `internal/models/*.go`:

1. **Update API definition** (`api/*.api`)
   - Update Type field definitions
   - Update Request/Response types
   - Add/update field comments

2. **Regenerate code**
   ```bash
   make gen
   ```

3. **Update Repository** (`internal/db/*.go`)
   - Add new query methods if needed
   - Update field lists in existing queries

4. **Update Logic layer** (`internal/logic/**/*.go`)
   - Update conversion functions (convert.go)
   - Update field mappings in create/update logic
   - Ensure defaults and validation

5. **Test**
   - Verify API request/response
   - Check database read/write
   - Validate field serialization

### Adding New Repository

1. Create `internal/db/xxx.go`
2. Add field to `Repository` struct in `internal/db/repo.go`
3. Initialize in `NewRepository` function

---

## Cache Architecture

### Rules

1. **Repository handles caching** - ALL cache logic in Repository layer
2. **Logic never touches cache** - No direct cache calls from Logic
3. **Auto-cleanup** - Repository methods clean cache after updates

```go
// ✅ Correct: Repository handles caching
func (r *UserRepository) GetByID(ctx context.Context, id int) (*model.User, error) {
    if r.userCache != nil {
        return r.userCache.GetUserByID(ctx, id, func() (*model.User, error) {
            return FirstOrNil[model.User](r.db.WithContext(ctx).Where("id = ?", id))
        })
    }
    return FirstOrNil[model.User](r.db.WithContext(ctx).Where("id = ?", id))
}

func (r *UserRepository) Update(ctx context.Context, user *model.User) error {
    err := r.db.WithContext(ctx).Save(user).Error
    if err != nil {
        return err
    }
    // Auto-cleanup cache
    if r.userCache != nil {
        r.userCache.DelUserByID(ctx, user.ID)
    }
    return nil
}

// ✅ Correct: Logic just calls Repository
func (l *GetUserByIDLogic) GetUserByID(req *types.GetUserByIDRequest) (*types.GetUserByIDResponse, error) {
    user, err := l.svcCtx.Repository.User.GetByID(l.ctx, req.ID)
    if err != nil {
        return nil, err
    }
    return &types.GetUserByIDResponse{User: ConvertUser(user)}, nil
}
```

**Detect violations:**
```bash
grep -r "svcCtx\..*Cache\." internal/logic/
# Should return 0 results
```

---

## Logging

### Writer vs Standard Logging

| Use Writer | Use Standard `l.Infof()` |
|---|---|
| System errors (DB/Redis/JWT) | Business logic errors |
| Critical user operations | Debug info, validation failures |

### log_type Values

| Type | Usage |
|---|---|
| `database` | Database errors |
| `redis` | Redis errors |
| `system` | Other system errors |
| `user` | User operation audit |
| `permission` | Permission changes |

### trace Field Format

**Format**: `Module.Method`

```go
// ✅ Correct: Module prefix
writer.Field("trace", "Result.CreateResult")
writer.Field("trace", "User.ListUsers")
writer.Field("trace", "Org.UpdateOrg")

// ❌ Wrong: Missing module
writer.Field("trace", "CreateResult")
```

### Examples

```go
// ✅ System error: Use Writer
l.svcCtx.Writer.Error("Database query failed",
    writer.Field("log_type", "database"),
    writer.Field("trace", "Result.ListResults"),
    writer.Field("error", err.Error()),
)

// ✅ Critical operation: Use Writer
l.svcCtx.Writer.Info("User login success",
    writer.Field("log_type", "user"),
    writer.Field("trace", "User.Login"),
    writer.Field("user_id", userID),
)

// ✅ Business error: Use standard logging
l.Infof("User not found: %s", loginName)
```

**Prohibited:**
- `fmt.Println` / `log.Printf`
- Logging sensitive data (passwords, keys)

---

## Code Reuse (DRY Principle)

### Identifying Duplication

**Signals:**
- Multiple functions with identical logic
- Changing one place requires syncing another

### Extraction Guidelines

| Duplication Scope | Extract To |
|---|---|
| Same package, multiple files | `helper.go` |
| Cross-package, same layer | `internal/common/` |
| Cross-layer | `internal/utils/` |

### Example

```go
// ❌ Wrong: Duplicated in multiple files
func (l *CreateUserLogic) syncManagerInfo(user *model.User) error { /* 50 lines */ }
func (l *UpdateUserLogic) syncManagerInfo(user *model.User) error { /* same 50 lines */ }

// ✅ Correct: Extract to helper.go
func syncManagerInfo(ctx context.Context, svcCtx *svc.ServiceContext, user *model.User, trace string) error {
    // Maintain single copy
}

// Usage
syncManagerInfo(l.ctx, l.svcCtx, user, "CreateUser")
```

### Call Existing Logic

**When to call existing Logic:**
- Same business logic needed
- Same side effects (cache clear, logging, syncing)
- Same validation rules

```go
// Create Logic instance and call
targetLogic := targetpackage.NewTargetLogic(l.ctx, l.svcCtx)
resp, err := targetLogic.TargetMethod(&types.TargetRequest{...})
if err != nil {
    l.svcCtx.Writer.Error("Call failed", writer.Field("error", err.Error()))
    return err
}
```

---

## Error Handling

### HTTP Response Errors

Distinguish "not found" (404) from other errors:

```go
// 1. Make HTTP request
resource, err := client.GetResource(token, id)

// 2. Check if 404
var respErr *types.ResponseError
is404 := errors.As(err, &respErr) && respErr.Code == 404

// 3. Return non-404 errors immediately
if err != nil && !is404 {
    return err
}

// 4. Handle not found (404 or nil)
if resource == nil || is404 {
    // Create resource or other logic
}
```

**Core Principle:**
- 404 is a business state (resource doesn't exist)
- Other errors are exceptions (network, permission, service failures)

---

## Type System Rules

### Bool Fields

**Rule:** ALL bool fields use `*bool`

**Reason:** Distinguish "not provided" from "provided as false"
- `nil` = not provided, don't update
- `&true` = explicitly set to true
- `&false` = explicitly set to false

```go
// API definition
type UpdateUserRequest {
    IsInternal *bool `json:"is_internal,optional"` // Is internal employee
}

// Model definition (remove default tag)
type User struct {
    IsInternal *bool `gorm:"type:boolean" json:"is_internal"`
}

// Create: Provide defaults
user := &model.User{
    IsInternal: boolWithDefault(req.IsInternal, true),  // default true
}

// Update: Only update if non-nil
if req.IsInternal != nil {
    updateData["is_internal"] = req.IsInternal
}

// Query: Three-state filtering
if filters.IsInternal != nil {
    query = query.Where("is_internal = ?", *filters.IsInternal)
}
```

**Helper functions in `internal/logic/user/helper.go`:**

```go
func boolPtr(b bool) *bool {
    return &b
}

func boolWithDefault(b *bool, defaultValue bool) *bool {
    if b == nil {
        return &defaultValue
    }
    return b
}
```

### JSON Serialization

Use `github.com/bytedance/sonic` instead of `encoding/json`:

```go
import "github.com/bytedance/sonic"

// ✅ Correct: Use sonic
data, err := sonic.Marshal(obj)
err = sonic.Unmarshal(data, &obj)

// ❌ Wrong: Standard library
data, err := json.Marshal(obj)
```

**Benefits:** 3-5x performance improvement, fully compatible API

---

## Code Style

### No Emojis

Prohibited in code, logs, comments, API responses.

```go
// ❌ Wrong
log.Info("⚠️ Warning message")
comment := "✅ Sync success"

// ✅ Correct
log.Info("[WARNING] Warning message")
comment := "[SUCCESS] Sync success"
```

Use: `[ERROR]`, `[WARNING]`, `[SUCCESS]`, `[INFO]`

### No Auto-Documentation

Do NOT automatically create:
- Task summaries
- TODO.md, CHANGELOG.md
- API usage guides
- Implementation summaries

Only create documentation when explicitly requested.

---

## Documentation & Resources

For library documentation and API references, use Context7 MCP:

1. Call `resolve-library-id` to get library ID
2. Call `query-docs` with the library ID
3. Maximum 3 calls per question

---

## Checklist

Before completing a task, verify:

### API Design
- [ ] Handler has `@doc` (summary + description)
- [ ] All fields have comments
- [ ] Enum fields list possible values
- [ ] Ran `make gen` to generate code

### Database
- [ ] Logic uses Repository, not direct DB
- [ ] Single record queries use helper functions
- [ ] New fields updated in API, models, logic, repository

### Cache
- [ ] Cache logic only in Repository layer
- [ ] No cache calls in Logic layer
- [ ] Cache cleaned after updates

### Code Quality
- [ ] No duplicate code (extracted to helper)
- [ ] Called existing Logic for shared operations
- [ ] Proper error handling (404 vs other errors)
- [ ] Bool fields use `*bool`
- [ ] Used sonic for JSON

### Style
- [ ] No emojis
- [ ] No auto-generated docs
- [ ] Proper logging (Writer vs standard)
- [ ] trace format: `Module.Method`

For detailed reference on specific topics, see the reference files in this directory.
